<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Modix - Dashboard (fetch)</title>
  <style>
    /* Reset simple */
    * { box-sizing:border-box; margin:0; padding:0; font-family:Inter,Arial,Helvetica,sans-serif; }
    body { background:#0b0b0d; color:#e6ffff; min-height:100vh; }
    a { color:inherit; }

    /* Canvas background */
    canvas#stars { position:fixed; inset:0; z-index:-2; }

    /* Header */
    header {
      position:fixed; inset-inline:0; top:0; display:flex; align-items:center; justify-content:space-between;
      padding:14px 22px; background:rgba(0,0,0,0.45); backdrop-filter: blur(8px);
      border-bottom:1px solid rgba(0,255,255,0.12); z-index:10;
    }
    header h1 { color:#00f0ff; font-size:1.25rem; text-shadow:0 0 6px rgba(0,240,255,0.1); }
    nav a { margin-left:18px; color:#8ff; font-weight:600; text-decoration:none; font-size:0.95rem; }
    nav a:hover { text-decoration:underline; }

    /* Container */
    .container { max-width:1100px; margin:110px auto 40px; padding:20px; }

    /* Grid for main panels */
    .grid { display:grid; grid-template-columns: repeat(3,1fr); gap:18px; align-items:start; }
    @media (max-width:900px) { .grid { grid-template-columns:repeat(1,1fr); } }

    /* Cards */
    .card {
      background: linear-gradient(180deg, rgba(15,15,15,0.85), rgba(12,12,12,0.6));
      border-radius:12px; padding:18px; box-shadow: 0 6px 30px rgba(0,220,255,0.03);
      border:1px solid rgba(0,255,255,0.06);
    }

    .stat { text-align:center; padding:18px 12px; }
    .stat h2 { font-size:2.5rem; color:#00f0ff; margin-bottom:6px; }
    .stat p { color:#9fe7ff; font-weight:600; }

    .tracks li { display:flex; justify-content:space-between; padding:10px 8px; border-radius:8px; margin-bottom:8px;
                 background:rgba(0,0,0,0.35); border:1px solid rgba(0,255,255,0.03); }
    .tracks li strong { color:#c9ffff; }

    pre.json {
      max-height:240px; overflow:auto; background:#021; padding:12px; border-radius:8px; margin-top:12px;
      color:#c8fffb; font-size:0.85rem; border:1px solid rgba(0,255,255,0.04);
    }

    /* Status */
    .status {
      position:fixed; right:18px; bottom:18px; padding:10px 14px; border-radius:10px; display:flex; gap:10px; align-items:center;
      background:linear-gradient(180deg, rgba(0,255,255,0.03), rgba(0,255,255,0.01)); color:#00f0ff; border:1px solid rgba(0,255,255,0.09);
      font-size:0.92rem; z-index:15;
    }
    .status.success { border-color: rgba(0,255,0,0.6); color:#8cff8c; background:rgba(0,255,0,0.03); }
    .status.error { border-color: rgba(255,80,80,0.9); color:#ff9b9b; background:rgba(255,0,0,0.03); }

    .spinner {
      width:14px; height:14px; border-radius:50%; border:2px solid rgba(255,255,255,0.12);
      border-top-color: #00f0ff; animation:spin 1s linear infinite;
    }
    @keyframes spin { to{ transform:rotate(360deg); } }

    footer { text-align:center; margin-top:30px; color:#7ff; opacity:0.7; font-size:0.9rem; }

    /* small helpers */
    .muted { color:#9fc; font-size:0.9rem; opacity:0.8; }
    .label { font-size:0.85rem; color:#9fe; margin-bottom:8px; display:block; }
  </style>
</head>
<body>
  <canvas id="stars"></canvas>

  <header>
    <h1>Modix Dashboard</h1>
    <nav>
      <a href="#stats">Stats</a>
      <a href="#music">Musique</a>
      <a href="#raw">Raw JSON</a>
    </nav>
  </header>

  <main class="container">
    <div class="grid">
      <!-- Stat cards -->
      <div class="card stat">
        <span class="label">Serveurs</span>
        <h2 id="servers">0</h2>
        <p class="muted">Serveurs où le bot est présent</p>
      </div>

      <div class="card stat">
        <span class="label">Membres en ligne</span>
        <h2 id="users">0</h2>
        <p class="muted">Utilisateurs connectés</p>
      </div>

      <div class="card">
        <span class="label">Dernière mise à jour</span>
        <div id="lastUpdate" class="muted">—</div>
        <div style="height:6px"></div>
        <button id="forceBtn" style="padding:8px 12px;border-radius:8px;border:0;background:#00e0ff;color:#001;cursor:pointer;font-weight:700;">Forcer update</button>
      </div>
    </div>

    <section style="margin-top:18px" class="card" id="music">
      <span class="label">Top Musiques Écoutées</span>
      <ul class="tracks" id="trackList" style="list-style:none;padding:0;margin:0">
        <li><span>Track 1</span><strong id="track1">0 plays</strong></li>
        <li><span>Track 2</span><strong id="track2">0 plays</strong></li>
        <li><span>Track 3</span><strong id="track3">0 plays</strong></li>
      </ul>
    </section>

    <section id="raw" class="card" style="margin-top:18px">
      <span class="label">JSON reçu (debug)</span>
      <pre id="rawJson" class="json">Aucune donnée reçue.</pre>
    </section>

    <footer>© 2025 Modix — Assure-toi que ton API autorise CORS et (si besoin) HTTPS</footer>
  </main>

  <div id="status" class="status"><div class="spinner"></div>⏳ Connexion...</div>

  <script>
  /*************************************************************************
   * CONFIG
   *
   * - Remplace API_URL par ta IP publique ou domaine :
   *   ex: "http://MON_IP:22324/stats" ou "https://mon-domaine.tld/stats"
   *
   * NOTES IMPORTANTES :
   * - Si ton site est servi en HTTPS, TON API doit être en HTTPS (ou via proxy).
   * - Active CORS sur l'API : Access-Control-Allow-Origin: *  (ou ton domaine)
   *************************************************************************/
  const API_URL = "http://TON_IP_PUBLIQUE:22324/stats"; // <-- MODIFIE ICI
  // const API_URL = "http://172.18.168.2:22324/stats"; // <-- option dev local
  const FETCH_TIMEOUT_MS = 6000;    // timeout par requête
  const MAX_RETRIES = 5;            // max tentatives avant pause longue
  const RETRY_BASE_MS = 1000;       // base pour retry exponentiel
  const UPDATE_INTERVAL_MS = 7000;  // intervalle "normal" entre mises à jour

  // Elements DOM
  const statusEl = document.getElementById("status");
  const serversEl = document.getElementById("servers");
  const usersEl = document.getElementById("users");
  const track1El = document.getElementById("track1");
  const track2El = document.getElementById("track2");
  const track3El = document.getElementById("track3");
  const rawJsonEl = document.getElementById("rawJson");
  const lastUpdateEl = document.getElementById("lastUpdate");
  const forceBtn = document.getElementById("forceBtn");

  let retryCount = 0;
  let nextTimeout = UPDATE_INTERVAL_MS;

  // Utility: fetch with timeout using AbortController
  async function fetchWithTimeout(url, timeoutMs = FETCH_TIMEOUT_MS) {
    const controller = new AbortController();
    const signal = controller.signal;
    const timer = setTimeout(() => controller.abort(), timeoutMs);
    try {
      const res = await fetch(url, { signal });
      clearTimeout(timer);
      return res;
    } catch (err) {
      clearTimeout(timer);
      throw err;
    }
  }

  // Update status UI helpers
  function setStatusLoading(text = "Connexion...") {
    statusEl.className = "status";
    statusEl.innerHTML = '<div class="spinner"></div>⏳ ' + text;
  }
  function setStatusSuccess(text = "Connecté") {
    statusEl.className = "status success";
    statusEl.innerHTML = '✅ ' + text;
  }
  function setStatusError(text = "Erreur de connexion") {
    statusEl.className = "status error";
    statusEl.innerHTML = '✗ ' + text;
  }

  // Animate numbers smoothly
  function animateValue(el, start, end, duration = 800) {
    el = (typeof el === "string") ? document.getElementById(el) : el;
    const obj = el;
    start = Number(start) || 0;
    end = Number(end) || 0;
    const range = end - start;
    if (range === 0) { obj.textContent = end; return; }
    const stepTime = Math.max(Math.floor(duration / Math.abs(range)), 10);
    let current = start;
    const increment = range > 0 ? 1 : -1;
    const timer = setInterval(() => {
      current += increment;
      obj.textContent = current;
      if (current === end) clearInterval(timer);
    }, stepTime);
  }

  // Traitement des données reçues
  function applyData(data) {
    // Exemples d'attribution : adapte selon ta structure JSON exacte
    const servers = (data.servers != null) ? data.servers : 0;
    const users = (data.users != null) ? data.users : 0;

    animateValue(serversEl, parseInt(serversEl.textContent || "0"), servers, 900);
    animateValue(usersEl, parseInt(usersEl.textContent || "0"), users, 900);

    // top_tracks
    if (data.top_tracks) {
      track1El.textContent = (data.top_tracks.track1 || 0) + " plays";
      track2El.textContent = (data.top_tracks.track2 || 0) + " plays";
      track3El.textContent = (data.top_tracks.track3 || 0) + " plays";
    }

    // affichage raw JSON pour debug
    rawJsonEl.textContent = JSON.stringify(data, null, 2);
    lastUpdateEl.textContent = new Date().toLocaleString();
  }

  // La boucle principale : fetch -> applyData -> schedule next fetch
  async function updateLoop() {
    setStatusLoading("Récupération...");
    try {
      const res = await fetchWithTimeout(API_URL, FETCH_TIMEOUT_MS);
      if (!res.ok) throw new Error("HTTP " + res.status);
      const data = await res.json();

      // reset retry variables on succès
      retryCount = 0;
      nextTimeout = UPDATE_INTERVAL_MS;

      applyData(data);
      setStatusSuccess("Connecté — dernière mise à jour affichée");

      // schedule next update
      setTimeout(updateLoop, nextTimeout);
    } catch (err) {
      console.warn("Fetch error:", err);
      retryCount++;
      setStatusError(`Erreur (${retryCount}/${MAX_RETRIES})`);
      // augmenter le délai exponentiellement
      nextTimeout = Math.min(30000, RETRY_BASE_MS * Math.pow(2, retryCount));
      // si on dépasse MAX_RETRIES, on ondule plus longtemps
      if (retryCount >= MAX_RETRIES) {
        // affichage erreur persistante + pause plus longue
        setStatusError("Echec répété — nouvelle tentative dans 30s");
        nextTimeout = 30000;
        retryCount = 0; // reset pour la prochaine série
      }
      setTimeout(updateLoop, nextTimeout);
    }
  }

  // Force update (bouton)
  forceBtn.addEventListener("click", () => {
    // reset et forcer fetch immédiat
    retryCount = 0;
    nextTimeout = UPDATE_INTERVAL_MS;
    updateLoop();
  });

  // Démarrage initial
  updateLoop();

  /*************************************************************************
   * Canvas stars léger (optionnel) - pas lourd et responsive
   *************************************************************************/
  (function starsCanvas(){
    const canvas = document.getElementById("stars");
    const ctx = canvas.getContext("2d");
    let w = canvas.width = innerWidth;
    let h = canvas.height = innerHeight;
    const N = Math.round((w*h)/50000); // densité adaptative
    const stars = Array.from({length: Math.max(60, N)}, () => ({
      x: Math.random()*w,
      y: Math.random()*h,
      r: Math.random()*1.6 + 0.2,
      vx: (Math.random()-0.5)*0.1,
      vy: (Math.random()-0.5)*0.1,
      a: Math.random()*0.8 + 0.2
    }));
    window.addEventListener("resize", () => { w = canvas.width = innerWidth; h = canvas.height = innerHeight; });

    function step(){
      ctx.clearRect(0,0,w,h);
      stars.forEach(s=>{
        ctx.globalAlpha = s.a;
        ctx.beginPath();
        ctx.fillStyle = "#00f0ff";
        ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
        ctx.fill();
        s.x += s.vx; s.y += s.vy;
        if (s.x < 0) s.x = w;
        if (s.x > w) s.x = 0;
        if (s.y < 0) s.y = h;
        if (s.y > h) s.y = 0;
      });
      requestAnimationFrame(step);
    }
    step();
  })();
  </script>
</body>
</html>
